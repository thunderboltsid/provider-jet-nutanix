/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CategoriesObservation struct {
}

type CategoriesParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type DevicePropertiesObservation struct {
}

type DevicePropertiesParameters struct {

	// +kubebuilder:validation:Optional
	DeviceType *string `json:"deviceType,omitempty" tf:"device_type,omitempty"`

	// +kubebuilder:validation:Optional
	DiskAddress map[string]*string `json:"diskAddress,omitempty" tf:"disk_address,omitempty"`
}

type DiskListObservation struct {
}

type DiskListParameters struct {

	// +kubebuilder:validation:Optional
	DataSourceReference map[string]*string `json:"dataSourceReference,omitempty" tf:"data_source_reference,omitempty"`

	// +kubebuilder:validation:Optional
	DeviceProperties []DevicePropertiesParameters `json:"deviceProperties,omitempty" tf:"device_properties,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSizeBytes *float64 `json:"diskSizeBytes,omitempty" tf:"disk_size_bytes,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSizeMib *float64 `json:"diskSizeMib,omitempty" tf:"disk_size_mib,omitempty"`

	// +kubebuilder:validation:Optional
	StorageConfig []StorageConfigParameters `json:"storageConfig,omitempty" tf:"storage_config,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeGroupReference map[string]*string `json:"volumeGroupReference,omitempty" tf:"volume_group_reference,omitempty"`
}

type GpuListObservation struct {
	Fraction *float64 `json:"fraction,omitempty" tf:"fraction,omitempty"`

	FrameBufferSizeMib *float64 `json:"frameBufferSizeMib,omitempty" tf:"frame_buffer_size_mib,omitempty"`

	GuestDriverVersion *string `json:"guestDriverVersion,omitempty" tf:"guest_driver_version,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NumVirtualDisplayHeads *float64 `json:"numVirtualDisplayHeads,omitempty" tf:"num_virtual_display_heads,omitempty"`

	PciAddress *string `json:"pciAddress,omitempty" tf:"pci_address,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type GpuListParameters struct {

	// +kubebuilder:validation:Optional
	DeviceID *float64 `json:"deviceId,omitempty" tf:"device_id,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Vendor *string `json:"vendor,omitempty" tf:"vendor,omitempty"`
}

type IPEndpointListObservation struct {
}

type IPEndpointListParameters struct {

	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type MachineObservation struct {
	APIVersion *string `json:"apiVersion,omitempty" tf:"api_version,omitempty"`

	ClusterName *string `json:"clusterName,omitempty" tf:"cluster_name,omitempty"`

	HostReference map[string]*string `json:"hostReference,omitempty" tf:"host_reference,omitempty"`

	HypervisorType *string `json:"hypervisorType,omitempty" tf:"hypervisor_type,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Metadata map[string]*string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	NicListStatus []NicListStatusObservation `json:"nicListStatus,omitempty" tf:"nic_list_status,omitempty"`

	PowerState *string `json:"powerState,omitempty" tf:"power_state,omitempty"`

	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type MachineParameters struct {

	// +kubebuilder:validation:Optional
	AvailabilityZoneReference map[string]*string `json:"availabilityZoneReference,omitempty" tf:"availability_zone_reference,omitempty"`

	// +kubebuilder:validation:Optional
	BootDeviceDiskAddress map[string]*string `json:"bootDeviceDiskAddress,omitempty" tf:"boot_device_disk_address,omitempty"`

	// +kubebuilder:validation:Optional
	BootDeviceMacAddress *string `json:"bootDeviceMacAddress,omitempty" tf:"boot_device_mac_address,omitempty"`

	// +kubebuilder:validation:Optional
	BootDeviceOrderList []*string `json:"bootDeviceOrderList,omitempty" tf:"boot_device_order_list,omitempty"`

	// +kubebuilder:validation:Optional
	BootType *string `json:"bootType,omitempty" tf:"boot_type,omitempty"`

	// +kubebuilder:validation:Optional
	Categories []CategoriesParameters `json:"categories,omitempty" tf:"categories,omitempty"`

	// +kubebuilder:validation:Optional
	CloudInitCdromUUID *string `json:"cloudInitCdromUuid,omitempty" tf:"cloud_init_cdrom_uuid,omitempty"`

	// +kubebuilder:validation:Required
	ClusterUUID *string `json:"clusterUuid" tf:"cluster_uuid,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	DiskList []DiskListParameters `json:"diskList,omitempty" tf:"disk_list,omitempty"`

	// +kubebuilder:validation:Optional
	EnableCPUPassthrough *bool `json:"enableCpuPassthrough,omitempty" tf:"enable_cpu_passthrough,omitempty"`

	// +kubebuilder:validation:Optional
	EnableScriptExec *bool `json:"enableScriptExec,omitempty" tf:"enable_script_exec,omitempty"`

	// +kubebuilder:validation:Optional
	GpuList []GpuListParameters `json:"gpuList,omitempty" tf:"gpu_list,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationCloudInitCustomKeyValues map[string]*string `json:"guestCustomizationCloudInitCustomKeyValues,omitempty" tf:"guest_customization_cloud_init_custom_key_values,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationCloudInitMetaData *string `json:"guestCustomizationCloudInitMetaData,omitempty" tf:"guest_customization_cloud_init_meta_data,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationCloudInitUserData *string `json:"guestCustomizationCloudInitUserData,omitempty" tf:"guest_customization_cloud_init_user_data,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationIsOverridable *bool `json:"guestCustomizationIsOverridable,omitempty" tf:"guest_customization_is_overridable,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationSysprep map[string]*string `json:"guestCustomizationSysprep,omitempty" tf:"guest_customization_sysprep,omitempty"`

	// +kubebuilder:validation:Optional
	GuestCustomizationSysprepCustomKeyValues map[string]*string `json:"guestCustomizationSysprepCustomKeyValues,omitempty" tf:"guest_customization_sysprep_custom_key_values,omitempty"`

	// +kubebuilder:validation:Optional
	GuestOsID *string `json:"guestOsId,omitempty" tf:"guest_os_id,omitempty"`

	// +kubebuilder:validation:Optional
	HardwareClockTimezone *string `json:"hardwareClockTimezone,omitempty" tf:"hardware_clock_timezone,omitempty"`

	// +kubebuilder:validation:Optional
	IsVcpuHardPinned *bool `json:"isVcpuHardPinned,omitempty" tf:"is_vcpu_hard_pinned,omitempty"`

	// +kubebuilder:validation:Optional
	MachineType *string `json:"machineType,omitempty" tf:"machine_type,omitempty"`

	// +kubebuilder:validation:Optional
	MemorySizeMib *float64 `json:"memorySizeMib,omitempty" tf:"memory_size_mib,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NgtCredentials map[string]*string `json:"ngtCredentials,omitempty" tf:"ngt_credentials,omitempty"`

	// +kubebuilder:validation:Optional
	NgtEnabledCapabilityList []*string `json:"ngtEnabledCapabilityList,omitempty" tf:"ngt_enabled_capability_list,omitempty"`

	// +kubebuilder:validation:Optional
	NicList []NicListParameters `json:"nicList,omitempty" tf:"nic_list,omitempty"`

	// +kubebuilder:validation:Optional
	NumSockets *float64 `json:"numSockets,omitempty" tf:"num_sockets,omitempty"`

	// +kubebuilder:validation:Optional
	NumVcpusPerSocket *float64 `json:"numVcpusPerSocket,omitempty" tf:"num_vcpus_per_socket,omitempty"`

	// +kubebuilder:validation:Optional
	NumVnumaNodes *float64 `json:"numVnumaNodes,omitempty" tf:"num_vnuma_nodes,omitempty"`

	// +kubebuilder:validation:Optional
	NutanixGuestTools map[string]*string `json:"nutanixGuestTools,omitempty" tf:"nutanix_guest_tools,omitempty"`

	// +kubebuilder:validation:Optional
	OwnerReference map[string]*string `json:"ownerReference,omitempty" tf:"owner_reference,omitempty"`

	// +kubebuilder:validation:Optional
	ParentReference map[string]*string `json:"parentReference,omitempty" tf:"parent_reference,omitempty"`

	// +kubebuilder:validation:Optional
	PowerStateMechanism *string `json:"powerStateMechanism,omitempty" tf:"power_state_mechanism,omitempty"`

	// +kubebuilder:validation:Optional
	ProjectReference map[string]*string `json:"projectReference,omitempty" tf:"project_reference,omitempty"`

	// +kubebuilder:validation:Optional
	SerialPortList []SerialPortListParameters `json:"serialPortList,omitempty" tf:"serial_port_list,omitempty"`

	// +kubebuilder:validation:Optional
	ShouldFailOnScriptFailure *bool `json:"shouldFailOnScriptFailure,omitempty" tf:"should_fail_on_script_failure,omitempty"`

	// +kubebuilder:validation:Optional
	UseHotAdd *bool `json:"useHotAdd,omitempty" tf:"use_hot_add,omitempty"`

	// +kubebuilder:validation:Optional
	VgaConsoleEnabled *bool `json:"vgaConsoleEnabled,omitempty" tf:"vga_console_enabled,omitempty"`
}

type NicListObservation struct {
}

type NicListParameters struct {

	// +kubebuilder:validation:Optional
	IPEndpointList []IPEndpointListParameters `json:"ipEndpointList,omitempty" tf:"ip_endpoint_list,omitempty"`

	// +kubebuilder:validation:Optional
	IsConnected *string `json:"isConnected,omitempty" tf:"is_connected,omitempty"`

	// +kubebuilder:validation:Optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkFunctionChainReference map[string]*string `json:"networkFunctionChainReference,omitempty" tf:"network_function_chain_reference,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkFunctionNicType *string `json:"networkFunctionNicType,omitempty" tf:"network_function_nic_type,omitempty"`

	// +kubebuilder:validation:Optional
	NicType *string `json:"nicType,omitempty" tf:"nic_type,omitempty"`

	// +kubebuilder:validation:Optional
	NumQueues *float64 `json:"numQueues,omitempty" tf:"num_queues,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	// +kubebuilder:validation:Optional
	SubnetUUID *string `json:"subnetUuid,omitempty" tf:"subnet_uuid,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type NicListStatusIPEndpointListObservation struct {
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type NicListStatusIPEndpointListParameters struct {
}

type NicListStatusObservation struct {
	FloatingIP *string `json:"floatingIp,omitempty" tf:"floating_ip,omitempty"`

	IPEndpointList []NicListStatusIPEndpointListObservation `json:"ipEndpointList,omitempty" tf:"ip_endpoint_list,omitempty"`

	IsConnected *string `json:"isConnected,omitempty" tf:"is_connected,omitempty"`

	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	NetworkFunctionChainReference map[string]*string `json:"networkFunctionChainReference,omitempty" tf:"network_function_chain_reference,omitempty"`

	NetworkFunctionNicType *string `json:"networkFunctionNicType,omitempty" tf:"network_function_nic_type,omitempty"`

	NicType *string `json:"nicType,omitempty" tf:"nic_type,omitempty"`

	NumQueues *float64 `json:"numQueues,omitempty" tf:"num_queues,omitempty"`

	SubnetName *string `json:"subnetName,omitempty" tf:"subnet_name,omitempty"`

	SubnetUUID *string `json:"subnetUuid,omitempty" tf:"subnet_uuid,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type NicListStatusParameters struct {
}

type SerialPortListObservation struct {
}

type SerialPortListParameters struct {

	// +kubebuilder:validation:Optional
	Index *float64 `json:"index,omitempty" tf:"index,omitempty"`

	// +kubebuilder:validation:Optional
	IsConnected *bool `json:"isConnected,omitempty" tf:"is_connected,omitempty"`
}

type StorageConfigObservation struct {
}

type StorageConfigParameters struct {

	// +kubebuilder:validation:Optional
	FlashMode *string `json:"flashMode,omitempty" tf:"flash_mode,omitempty"`

	// +kubebuilder:validation:Optional
	StorageContainerReference []StorageContainerReferenceParameters `json:"storageContainerReference,omitempty" tf:"storage_container_reference,omitempty"`
}

type StorageContainerReferenceObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type StorageContainerReferenceParameters struct {

	// +kubebuilder:validation:Optional
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

// MachineSpec defines the desired state of Machine
type MachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MachineParameters `json:"forProvider"`
}

// MachineStatus defines the observed state of Machine.
type MachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Machine is the Schema for the Machines API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nutanixjet}
type Machine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MachineSpec   `json:"spec"`
	Status            MachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MachineList contains a list of Machines
type MachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Machine `json:"items"`
}

// Repository type metadata.
var (
	Machine_Kind             = "Machine"
	Machine_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Machine_Kind}.String()
	Machine_KindAPIVersion   = Machine_Kind + "." + CRDGroupVersion.String()
	Machine_GroupVersionKind = CRDGroupVersion.WithKind(Machine_Kind)
)

func init() {
	SchemeBuilder.Register(&Machine{}, &MachineList{})
}
